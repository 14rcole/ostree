#!/usr/bin/python

# Copyright 2010, 2011 Colin Walters <walters@verbum.org>
# Licensed under the new-BSD license (http://www.opensource.org/licenses/bsd-license.php)

# ostbuild-compile-one-make wraps systems that implement the GNOME build API:
# http://people.gnome.org/~walters/docs/build-api.txt

import os,sys,subprocess,tempfile,re
from multiprocessing import cpu_count
import select,time

tempfiles = []

_devel_regexps = map(re.compile,
                     [r'/usr/include/',
                      r'/usr/share/pkgconfig/',
                      r'/.*lib(?:|(?:32)|(?:64))/pkgconfig/.*\.pc',
                      r'/.*lib(?:|(?:32)|(?:64))/.*\.so$'])

root = None

prefix = '/usr'

# libdir detection
if os.path.isdir('/lib64'):
    libdir=os.path.join(prefix, 'lib64')
else:
    libdir=os.path.join(prefix, 'lib')

default_buildapi_jobs = ['-j', '%d' % (cpu_count() * 2, )]
configargs = ['--prefix=' + prefix,
              '--libdir=' + libdir,
              '--sysconfdir=/etc',
              '--localstatedir=/var',
              '--bindir=' + os.path.join(prefix, 'bin'),
              '--sbindir=' + os.path.join(prefix, 'sbin'),
              '--datadir=' + os.path.join(prefix, 'share'),
              '--includedir=' + os.path.join(prefix, 'include'),
              '--libexecdir=' + os.path.join(prefix, 'libexec'),
              '--mandir=' + os.path.join(prefix, 'share', 'man'),
              '--infodir=' + os.path.join(prefix, 'share', 'info')]
makeargs = ['make']

top_srcdir=os.getcwd()

for arg in sys.argv[1:]:
    if arg.startswith('--'):
        configargs.append(arg)
    else:
        makeargs.append(arg)

def log(msg):
    fullmsg = '%s: %s\n' % (sys.argv[0], msg)
    sys.stdout.write(fullmsg)
    sys.stdout.flush()

def fatal(msg):
    log(msg)
    sys.exit(1)

def run_sync(args, cwd=None, env=None):
    log("running: %r" % (args,))
    f = open('/dev/null', 'r')
    proc = subprocess.Popen(args, stdin=f, stdout=sys.stdout, stderr=sys.stderr,
                            close_fds=True, cwd=cwd, env=env)
    f.close()
    returncode = proc.wait()
    log("pid %d exited with code %d" % (proc.pid, returncode))
    if returncode != 0:
        sys.exit(1)

class BuildSystemScanner(object):
    @classmethod
    def _find_file(cls, names):
        for name in names:
            if os.path.exists(name):
                return name
        return None

    @classmethod
    def get_configure_source_script(cls):
        return cls._find_file(('./configure.ac', './configure.in'))

    @classmethod
    def get_configure_script(cls):
        return cls._find_file(('./configure', ))

    @classmethod
    def get_bootstrap_script(cls):
        return cls._find_file(('./autogen.sh', ))

    @classmethod
    def get_silent_rules(cls):
        src = cls.get_configure_source_script()
        if not src:
            return False
        f = open(src)
        for line in f:
            if line.find('AM_SILENT_RULES') >= 0:
                f.close()
                return True
        f.close()
        return False

def _search_file(filename, pattern):
    f = open(filename)
    for line in f:
        if line.startswith(pattern):
            f.close()
            return line
    f.close()
    return None

def _find_buildapi_makevariable(name, builddir='.'):
    var = '.%s:' % (name, )
    line = None
    path = os.path.join(builddir, 'Makefile.in')
    if os.path.exists(path):
        line = _search_file(path, var)
    path = os.path.join(builddir, 'Makefile')
    if not line and os.path.exists(path):
        line = _search_file(path, var)
    return line is not None

def phase_bootstrap():        
    have_configure = BuildSystemScanner.get_configure_script() 
    have_configure_source = BuildSystemScanner.get_configure_source_script()
    if not (have_configure or have_configure_source):
        fatal("No configure or bootstrap script detected; unknown buildsystem")
        return

    need_v1 = BuildSystemScanner.get_silent_rules()
    if need_v1:
        log("Detected AM_SILENT_RULES, adding --disable-silent-rules to configure")
        configargs.append('--disable-silent-rules')

    if have_configure:
        phase_configure()
    else:
        bootstrap = BuildSystemScanner.get_bootstrap_script()
        if bootstrap:
            log("Detected bootstrap script: %s, using it" % (bootstrap, ))
            args = [bootstrap]
            args.extend(configargs)
            # Add NOCONFIGURE; GNOME style scripts use this
            env = dict(os.environ)
            env['NOCONFIGURE'] = '1'
            run_sync(args, env=env)
        else:
            log("No bootstrap script found; using generic autoreconf")
            run_sync(['autoreconf', '-f', '-i'])
        phase_configure()

def phase_configure():
    use_builddir = True
    doesnot_support_builddir = _find_buildapi_makevariable('buildapi-no-builddir')
    if doesnot_support_builddir:
        log("Found .buildapi-no-builddir; copying source tree to _build")
        shutil.rmtree('_build')
        os.mkdir('_build')
        shutil.copytree('.', '_build', symlinks=True,
                        ignore=shutil.ignore_patterns('_build'))
        use_builddir = False
        builddir = '.'
    else:
        builddir = '_build'

    if not use_builddir:
        configdir = './'
    else:
        configdir = os.getcwd()
        builddir = builddir
        log("Using build directory %r" % (builddir, ))
        if not os.path.isdir(builddir):
            os.mkdir(builddir)

    configstatus = 'config.status'
    if not os.path.exists(configstatus):
        args = [os.path.join(configdir, 'configure')]
        args.extend(configargs)
        run_sync(args, cwd=builddir)
    else:
        log("Found %s, skipping configure" % (configstatus, ))
    phase_build(builddir=builddir)

build_status = False

def phase_build(builddir=None):
    if not os.path.exists(os.path.join(builddir, 'Makefile')):
        log("No Makefile found")
        sys.exit(1)
    args = makeargs
    user_specified_jobs = False
    for arg in args:
        if arg == '-j':
            user_specified_jobs = True

    if not user_specified_jobs:
        notparallel = _find_buildapi_makevariable('NOTPARALLEL', builddir=builddir)
        if not notparallel:
            log("Didn't find NOTPARALLEL, using parallel make by default")
            args.extend(default_buildapi_jobs)

    run_sync(args, cwd=builddir)

    phase_make_artifacts(builddir=builddir)

def make_artifact(name, from_files, fakeroot_temp=None, tempdir=None):
    targz_name = name + '.tar.gz'
    (fd,filelist_temp)=tempfile.mkstemp(prefix='ostree-filelist-%s' % (name, ))
    os.close(fd)
    tempfiles.append(filelist_temp)
    f = open(filelist_temp, 'w')
    for filename in from_files:
        assert ('\n' not in filename)
        f.write(filename)
        f.write('\n')
    f.close()
    args = ['fakeroot', '-i', fakeroot_temp, 'tar', '-c', '-z', '-C', tempdir, '-f', targz_name, '-T', filelist_temp]
    run_sync(args)
    log("created: %s" % (os.path.abspath (targz_name), ))

def phase_make_artifacts(builddir=None):
    basename=os.path.basename(os.getcwd())
    
    try:
        version = subprocess.check_output(['git', 'describe'])
    except subprocess.CalledProcessError, e:
        version = subprocess.check_output(['git', 'rev-parse', 'HEAD'])
    version = version.strip()

    artifact_prefix='artifact-%s,%s' % (basename, version)

    (fd,fakeroot_temp)=tempfile.mkstemp(prefix='ostree-fakeroot-%s-' % (basename,))
    os.close(fd)
    tempfiles.append(fakeroot_temp)
    tempdir = tempfile.mkdtemp(prefix='ostree-build-%s-' % (basename,))
    tempfiles.append(tempdir)
    args = ['fakeroot', '-s', fakeroot_temp, 'make', 'install', 'DESTDIR=' + tempdir]
    run_sync(args, cwd=builddir)

    devel_files = set()
    runtime_files = set()

    oldpwd=os.getcwd()
    os.chdir(tempdir)
    for root, dirs, files in os.walk('.'):
        for filename in files:
            path = os.path.join(root, filename)
            matched = False
            for r in _devel_regexps:
                if not r.match(path[1:]):
                    continue
                devel_files.add(path)
                matched = True
                break
            if not matched:    
                runtime_files.add(path)
    os.chdir(oldpwd)

    if devel_files:
        make_artifact(artifact_prefix + '-devel', devel_files, fakeroot_temp=fakeroot_temp, tempdir=tempdir)
    make_artifact(artifact_prefix + '-runtime', runtime_files, fakeroot_temp=fakeroot_temp, tempdir=tempdir)

def phase_complete():
    for tmpname in tempfiles:
        if os.path.isdir(tmpname):
            shutil.rmtree(tmpname)
        else:
            try:
                os.unlink(tmpname)
                pass
            except OSError, e:
                pass
    sys.exit(0)

log("invocation arguments: %r" % (sys.argv, ))

# Start off the process
phase_bootstrap()
